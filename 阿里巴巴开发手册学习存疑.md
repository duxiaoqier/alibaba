1. 高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：

集合类 | Key | Value | Super | 说明
---|---|---|---|---
Hashtable | 不允许为 null | 不允许为null | Dictionary | 不允许为null
ConcurrentHashMap | 不允许为 null | 不允许为null | AbstractMap | ==线程局部安全==
TreeMap | 不允许为 null | 允许为null | AbstractMap | 线程不安全
HashMap | 允许为 null | 允许为null | AbstractMap | 线程不安全

 - ~~反例~~：很多同学认为ConcurrentHashMap是可以置入null值。在批量翻译场景中，子线程分发时，出现置入null值的情况，但主线程没有捕获到此异常，导致排查困难。

2. SQL 性能优化的目标： 至少要达到 range 级别， 要求是 ref 级别， 如果可以是 consts最好。
    - ==说明==：
        - consts 单表中最多只有一个匹配行 （主键或者唯一索引） ， 在优化阶段即可读取到数据。
        - ref 指的是使用普通的索引。（normal index）
        - range 对索引进范围检索。
    - ~~反例~~：explain 表的结果，type=index，==索引物理文件全扫描==，速度非常慢，这个 index 级别
    比较 range 还低，与全表扫描是小巫见大巫。

3. 创建索引时避免有如下极端误解：
    - 误认为一个查询就需要建一个索引。
    - 误认为索引会消耗空间、严重拖慢更新和新增速度。
    - 误认为唯一索引一律需要在应用层通过“先查后插”方式解决。

4. 应用分层。图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web 层，也可以直接依赖于 Service 层，依此类推：
![image](http://duxiaoqier-src.oss-cn-shanghai.aliyuncs.com/application.png)
    - 开放接口层：可直接封装 Service 接口暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。
    - 终端显示层：各个端的模板渲染并执行显示层。当前主要是 velocity 渲染，JS 渲染，JSP 渲
染，移动端展示层等。
    - Web  层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。
    - Service  层：相对具体的业务逻辑服务层。
    - ==Manager  层==：通用业务处理层，它有如下特征：
        - 对第三方平台封装的层，预处理返回结果及转化异常信息；
        - 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；
        - 与 DAO 层交互，对 DAO 的业务通用能力的封装。
    - DAO  层：数据访问层，与底层 Mysql、Oracle、Hbase、OB 进行数据交互。
    - 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。
5. 为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：
    - 精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是 ==provided 引入==，让二方库使用者去依赖具体版本号；==无log具体实现，只依赖日志框架。==
    - 稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能
    方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。